#pragma config(Sensor, port6,  leftTouch,      sensorNone)
#pragma config(Motor,  motor1,          left,          tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor2,          right,         tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor3,          side,          tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor4,           ,             tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor5,          armMotor,      tmotorNone, openLoop)
#pragma config(Motor,  motor9,          rearClaw,      tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

static float armRequestedValue;
static bool armMoving;
task armPID(){

			resetMotorEncoder(armMotor);
			float  pidError;
  	  float  pidLastError;
  	  float  pidIntegral;
   	  float  pidDerivative;
    	float  pidDrive;

			float  pidKp = 1;
			float  pidKi = 0.01;
			float  pidKd = 0.00;

    	pidLastError = 0;
			pidIntegral = 0;

			while(true){
					if(armMoving){
							pidError = (getMotorEncoder(armMotor)) - armRequestedValue;
							writeDebugStreamLine("%d - %d == %d\n", (getMotorEncoder(armMotor)),armRequestedValue, pidError);
							if(pidKi != 0)
                {
                		if(abs(pidError) < 10000000000000)
                 		 	  pidIntegral = pidIntegral + pidError;
                		else
                  		  pidIntegral = 0;
                }
              pidDerivative = pidError - pidLastError;
  	          pidLastError  = pidError;

  	          pidDrive = (pidKp * pidError) + (pidKi * pidIntegral) + (pidKd * pidDerivative);
							//writeDebugStreamLine("%d\n", pidDrive);

              if(pidDrive > 100)
              		pidDrive = 100;
              if(pidDrive < -100)
              		pidDrive = -100;
              motor[armMotor] = -pidDrive;

					}
					else{
							pidError = 0;
    			    pidLastError = 0;
  		    	  pidIntegral = 0;
           	  pidDerivative = 0;
           	  motor[armMotor] = 0;
         }
         wait1Msec(25);
			}

}

task main()
{
	startTask(armPID);
	armMoving = true;
	//armRequestedValue = -100
	bool isReversed = false;
	clearTimer(T1);
	while(true) {

		writeDebugStreamLine("Encoder Value: %d\n", (getMotorEncoder(armMotor)));
		//writeDebugStreamLine("%s\n", sensorType[gyro]);
		motor[left] = getJoystickValue(ChC) + getJoystickValue(ChA);
		motor[right] = getJoystickValue(ChC) - getJoystickValue(ChA);
		motor[side] = -getJoystickValue(ChB);

		if(getJoystickValue(BtnLUp) == 1 && armRequestedValue > -700) {
			armRequestedValue -= 0.1;
		}

		else if(getJoystickValue(BtnLDown) == 1 && armRequestedValue < 50) {
			armRequestedValue += 0.1;
		}
//		if(getJoystickValue(BtnRUp) == 1) {
//			motor[rearClaw] = -30;
//		}
//		else if(getJoystickValue(BtnRDown) == 1) {
//			motor[rearClaw] = 30;
//		}
//		else {
//			motor[rearClaw] = 0;
//		}
		if(getJoystickValue(BtnFDown)){
				armRequestedValue = -105;
		}

		if(getJoystickValue(BtnFUp) && time10[T1] >= 20){
			setMotorReversed(right, !isReversed);
			setMotorReversed(left, !isReversed);
			setMotorReversed(side, !isReversed);
			isReversed = !isReversed;
			clearTimer(T1);
		}
	}
}
