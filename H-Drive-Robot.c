#pragma config(Motor,  motor1,          left,          tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor2,          right,         tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor3,          side,          tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor5,          rightArmMotor, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          leftArmMotor,  tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor9,          rearClaw,      tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

static float armRequestedValue;
static bool armMoving;

task moveArm(){
		while(true){
			if(abs((getMotorEncoder(leftArmMotor) + getMotorEncoder(rightArmMotor)) / 2) - -200 > 200){
					if(((getMotorEncoder(leftArmMotor) + getMotorEncoder(rightArmMotor)) / 2) > -200){
						motor[leftArmMotor] = -100;
						motor[rightArmMotor] = -100;
					}
					if(((getMotorEncoder(leftArmMotor) + getMotorEncoder(rightArmMotor)) / 2) < -200){
						motor[leftArmMotor] = 100;
						motor[rightArmMotor] = 100;
					}
			}
				else{

					motor[leftArmMotor] = 0;
					motor[rightArmMotor] = 0;
					stopTask(moveArm);
				}
		}
}
task armPID(){

			resetMotorEncoder(rightArmMotor);
			float  pidError;
  	  float  pidLastError;
  	  float  pidIntegral;
   	  float  pidDerivative;
    	float  pidDrive;

			float  pidKp = 1;
			float  pidKi = 0.01;
			float  pidKd = 0.00;

    	pidLastError = 0;
			pidIntegral = 0;

			while(true){
					if(armMoving){
							pidError = (getMotorEncoder(rightArmMotor)) - armRequestedValue;
							writeDebugStreamLine("%d - %d == %d\n", (getMotorEncoder(rightArmMotor)),armRequestedValue, pidError);
							if(pidKi != 0)
                {
                		if(abs(pidError) < 10000000000000)
                 		 	  pidIntegral = pidIntegral + pidError;
                		else
                  		  pidIntegral = 0;
                }
              pidDerivative = pidError - pidLastError;
  	          pidLastError  = pidError;

  	          pidDrive = (pidKp * pidError) + (pidKi * pidIntegral) + (pidKd * pidDerivative);
							//writeDebugStreamLine("%d\n", pidDrive);

              if(pidDrive > 100)
              		pidDrive = 100;
              if(pidDrive < -100)
              		pidDrive = -100;
              motor[rightArmMotor] = -pidDrive;

					}
					else{
							pidError = 0;
    			    pidLastError = 0;
  		    	  pidIntegral = 0;
           	  pidDerivative = 0;
           	  motor[rightArmMotor] = 0;
         }
         wait1Msec(25);
			}

}

task main()
{
	startTask(armPID);
	armMoving = true;
	//armRequestedValue = -100
	bool isReversed = false;
	clearTimer(T1);
	while(true) {

		//writeDebugStreamLine("rightArmMotor: %d\n", getMotorEncoder(rightArmMotor));
		//writeDebugStreamLine("%s\n", sensorType[gyro]);

		motor[left] = -getJoystickValue(ChA) - getJoystickValue(ChC);
		motor[right] = -getJoystickValue(ChA) + getJoystickValue(ChC);
		motor[side] = getJoystickValue(ChB);

		//if(getJoystickValue(BtnLUp) == 1 && armRequestedValue > -700) {
		//	armRequestedValue -= 0.1;
		//}

		//else if(getJoystickValue(BtnLDown) == 1 && armRequestedValue < 50) {
		//	armRequestedValue += 0.1;
		//}
		if(getJoystickValue(BtnLUp) == 1){
				motor[rightArmMotor] = -100;
				motor[leftArmMotor] = -100;
		}
		else if(getJoystickValue(BtnLDown) == 1){
				motor[rightArmMotor] = 50;
				motor[leftArmMotor] = 50;
		}
		else{
				motor[rightArmMotor] = 0;
				motor[leftArmMotor] = 0;
		}
		if(getJoystickValue(BtnFDown)){
				startTask(moveArm);
		}

		if(getJoystickValue(BtnFUp) && time10[T1] >= 20){
			setMotorReversed(right, !isReversed);
			setMotorReversed(left, !isReversed);
			setMotorReversed(side, !isReversed);
			isReversed = !isReversed;
			clearTimer(T1);
		}
	}
}
