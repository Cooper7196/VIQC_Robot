#pragma config(Sensor, port2,  gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port7,  touchSensor,    sensorVexIQ_LED)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor3,          leftArmMotor,  tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor4,          claw,          tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor5,          rightArmMotor, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor8,          sideMotor,     tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

static float armRequestedValue;
static bool armMoving;

task armPID(){

			resetMotorEncoder(rightArmMotor);
			//resets motor encoder
			float  pidError;
  	  float  pidLastError;
  	  float  pidIntegral;
   	  float  pidDerivative;
    	float  pidDrive;

			float  pidKp = 1;
			float  pidKi = 0.02;
			float  pidKd = 0.015;

    	pidLastError = 0;
			pidIntegral = 0;

			while(true){
					if(armMoving){
							pidError = (getMotorEncoder(rightArmMotor)) - armRequestedValue;
							if(pidKi != 0)
                {
                		if(abs(pidError) < 100)
                 		 	  pidIntegral = pidIntegral + pidError;
                		else
                  		  pidIntegral = 0;
                }
              pidDerivative = pidError - pidLastError;
  	          pidLastError  = pidError;

  	          pidDrive = (pidKp * pidError) + (pidKi * pidIntegral) + (pidKd * pidDerivative);

              if(pidDrive > 100){
              		pidDrive = 100;
              	}
              if(pidDrive < -100){
              		pidDrive = -100;
              	}
              motor[rightArmMotor] = -pidDrive;

					}
					else{
							pidError = 0;
    			    pidLastError = 0;
  		    	  pidIntegral = 0;
           	  pidDerivative = 0;
         }
         wait1Msec(25);
			}
}


task main()
{
		//startTask(armPID);
		armMoving = false;

		while(true) {
			motor[leftArmMotor] = motor[rightArmMotor];

			motor[rightMotor] = getJoystickValue(ChA) - getJoystickValue(ChC);
			motor[leftMotor] = getJoystickValue(ChA) + getJoystickValue(ChC);
			motor[sideMotor] = getJoystickValue(ChB);


			if(getJoystickValue(BtnRUp) == 1) {
					motor[claw] = 127;
			}

			else if(getJoystickValue(BtnRDown) == 1) {
					motor[claw] = -127;
			}
			else{
					motor[claw] = 0;
			}
			// && armRequestedValue > -460
			if(getJoystickValue(BtnLUp) == 1 && getMotorEncoder(rightArmMotor) > -350){// && armRequestedValue > -450) {
				//armRequestedValue -= 0.04;
				motor[rightArmMotor] = -127;
			}

			else if(getJoystickValue(BtnLDown) == 1){// && armRequestedValue < 50) {
				//armRequestedValue += 0.04;
				motor[rightArmMotor] = 60;
			}
			else {
				motor[rightArmMotor] = 0;
			}
		}
}
