#pragma config(Sensor, port2,  gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port7,  touchSensor,    sensorVexIQ_LED)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor3,          leftArmMotor,  tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor4,          claw,          tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor5,          rightArmMotor, tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor8,          sideMotor,     tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void rotate(float angle, float kp, float kd){
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);
	float error = 0;
	float lastError = 0;
	float derivative = 0;
	float output = 0;
	while(getGyroHeading(gyro) < angle){
		error = angle - getGyroHeading(gyro);
		derivative = error - lastError;
		lastError  = error;
		output = (error * kp) + (derivative * kd);
		motor[leftMotor] = -output;
		motor[rightMotor] = output;
	}
	while(getGyroHeading(gyro) > angle){
		error = angle - getGyroHeading(gyro);
		derivative = error - lastError;
		lastError  = error;
		output = (error * kp) + (derivative * kd);
		motor[leftMotor] = -output;
		motor[rightMotor] = output;
	}
	motor[rightMotor] = 0;
	motor[leftMotor]	= 0;
}


void strafe(int amount, int speed){
	resetMotorEncoder(sideMotor);

	if(amount > 0){
		motor[sideMotor]	= speed;
	}
	else if(amount < 0){
		motor[sideMotor] = -speed;
	}
	else{
		motor[sideMotor] = 0;
	}
	while(abs(getMotorEncoder(sideMotor) - amount) > 40){}
	motor[sideMotor] = 0;
}

void drive(float amount, float speed, float kp, float kd){
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);
	float angle = getGyroHeadingFloat(gyro);
	float error = 0;
	float output = 0;
	float lastError = 0;
	float derivative = 0;

	if (speed > 0){
		while(getMotorEncoder(leftMotor) < amount){
			error = angle - getGyroHeadingFloat(gyro);
			lastError  = error;
			output = (error * kp) + (derivative * kd);
			motor[leftMotor] = speed - output;
			motor[rightMotor] = speed + output;
		}
	}
	else{
		while(getMotorEncoder(leftMotor) > (-amount)){
			error = angle - getGyroHeadingFloat(gyro);
			lastError  = error;
			output = (error * kp) + (derivative * kd);
			motor[leftMotor] = speed - output;
			motor[rightMotor] = speed + output;
		}
	}
	motor[rightMotor] = 0;
	motor[leftMotor]	= 0;
}
void moveClaw(bool raise){
	if(raise){
		motor[claw] = -100;
	}
	else{
		motor[claw] = 100;
	}
	wait10Msec(100);
	//motor[claw] = 0;
}

void moveArm(int amount, int speed){
	resetMotorEncoder(leftArmMotor);
	resetMotorEncoder(rightArmMotor);
	if(amount > 0){
		motor[leftArmMotor]	= speed;
		motor[rightArmMotor]	= speed;
	}
	else if(amount < 0){
		motor[leftArmMotor]	= -speed;
		motor[rightArmMotor]	= -speed;
	}
	else{
		motor[leftArmMotor]	= 0;
		motor[rightArmMotor] = 0;
	}
	while(abs((getMotorEncoder(rightArmMotor) + getMotorEncoder(leftArmMotor)) / 2 - amount) > 20){
	}
	motor[leftArmMotor]	= 0;
	motor[rightArmMotor] = 0;
}

void firstRiser(){
	//setMotorBrakeMode(leftMotor, motorHold);
	//setMotorBrakeMode(rightMotor, motorHold);
	setMotorBrakeMode(leftArmMotor, motorHold);
	setMotorBrakeMode(rightArmMotor, motorHold);
	moveClaw(true);
	drive(45, 80, 2, 2);
	moveArm(300, 100);
	rotate(-90, 2, 1);
	drive(1100, 80, 2, 2);
	drive(500, -80, 2, 2);
	moveClaw(true);
	rotate(-70, 2, 1);
	moveArm(-300, 100);
	rotate(-70, 2, 1);
	drive(400, 80, 2, 2);
	moveClaw(false);
	moveArm(30, 100);
	moveArm(330, 100);
	rotate(-120, 2, 1);
	drive(40, -80, 2, 2);
	moveArm(-110, 100);
	moveClaw(true);
	drive(425, -80, 2, 2);
	//setMotorBrakeMode(leftMotor, motorCoast);
	//setMotorBrakeMode(rightMotor, motorCoast);
	setMotorBrakeMode(leftArmMotor, motorCoast);
	setMotorBrakeMode(rightArmMotor, motorCoast);
}

void secondRiser(){
	//setMotorBrakeMode(leftMotor, motorHold);
	//setMotorBrakeMode(rightMotor, motorHold);
	setMotorBrakeMode(leftArmMotor, motorHold);
	setMotorBrakeMode(rightArmMotor, motorHold);
	moveClaw(true);
	//moveArm(300, 100);
	drive(900, 80, 2, 2);
	strafe(-300, 80);
	rotate(-90, 2, 1);
	//moveClaw(false);
	drive(650, 80, 2, 2);
	rotate(-90, 2, 1);
	drive(1200, -80, 2, 2);
	rotate(-90, 2, 1);
	drive(675, 80, 2, 2);

		//setMotorBrakeMode(leftMotor, motorCoast);
	//setMotorBrakeMode(rightMotor, motorCoast);
	setMotorBrakeMode(leftArmMotor, motorCoast);
	setMotorBrakeMode(rightArmMotor, motorCoast);
	}


void thirdRiser(){
	//setMotorBrakeMode(leftMotor, motorHold);
	//setMotorBrakeMode(rightMotor, motorHold);
	setMotorBrakeMode(leftArmMotor, motorHold);
	setMotorBrakeMode(rightArmMotor, motorHold);
	moveArm(350, 100);
	moveClaw(true);
	drive(1550, 80, 2, 2);
	strafe(-300, 80);
	rotate(-90, 2, 1);
	strafe(-75, 80);
	drive(800, 80, 3, 5);
	drive(450, -80, 2, 2);
	moveArm(-350, 100);
	rotate(-105, 2, 1);
	moveClaw(true);
	drive(335, 80, 2, 2);
	moveClaw(false);
	moveArm(350, 100);
	drive(75, -80, 2, 2);
	rotate(-73, 2, 1);
	moveArm(-100, 50);
	moveClaw(true);
	drive(500, -80, 2, 2);
}

task main()
{
setTouchLEDColor(touchSensor, colorRed);
startGyroCalibration(gyro, gyroCalibrateSamples2048);
while(getGyroCalibrationFlag(gyro)){}
wait10Msec(500);
setTouchLEDColor(touchSensor, colorGreen);
while(!getTouchLEDValue(touchSensor)){}
setTouchLEDColor(touchSensor, colorNone);
resetGyro(gyro);
firstRiser();
rotate(0, 2, 1);
secondRiser();
rotate(0, 2, 1);
thirdRiser();
/*
drive(2000, 80, 2, 2);
rotate(-90, 2, 1);
*/

}
