#pragma config(Sensor, port4,  gyro,           sensorVexIQ_Gyro)
#pragma config(Motor,  motor1,          left,          tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor2,          right,         tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor3,          side,          tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor5,          rightArmMotor, tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor6,          leftArmMotor,  tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor10,         frontClaw,     tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void rotate(float angle){
	while(abs(getGyroHeadingFloat(gyro) - angle) > 0.2){
		writeDebugStreamLine("%d", getGyroHeadingFloat(gyro));
		float angleDifference = abs(getGyroHeadingFloat(gyro) - angle);
		float speed = (angleDifference - 0) / (180 - 0) * (100 - 10) + 10;
		writeDebugStreamLine("%d", angleDifference );
		if(getGyroHeading(gyro) > angle){// && abs(getGyroHeading(gyro) - angle) > 40){
			motor[left] = speed;
			motor[right] = -speed;
		}
		else if(getGyroHeading(gyro) < angle){// && abs(getGyroHeading(gyro) - angle) > 40){
			motor[left] = -speed;
			motor[right] = speed;
		}
	}
	motor[left] = 0;
	motor[right] = 0;
}

void strafe(int amount, int speed){
	resetMotorEncoder(side);

	if(amount > 0){
		motor[side]	= speed;
	}
	else if(amount < 0){
		motor[side] = -speed;
	}
	else{
		motor[side] = 0;
	}
	while(abs(getMotorEncoder(side) - amount) > 40){}
	motor[side] = 0;
}

void drive(int amount, int speed){
	float angle = getGyroHeadingFloat(gyro);


	resetMotorEncoder(right);
	resetMotorEncoder(left);
	if(amount > 0){
		motor[left]	= speed;
		motor[right] = speed;
	}
	else if(amount < 0){
		motor[left]	= -speed;
		motor[right] = -speed;
	}
	else{
		motor[left]	= 0;
		motor[right] = 0;
	}

	int currentSpeed = motor[right];
	while(abs(getMotorEncoder(right) - amount) > 40){
		float angleDifference = getGyroHeadingFloat(gyro) - angle;
		float rotationSpeed = (angleDifference - 0) / (360 - 0) * (100 - 10) + 10;
		writeDebugStreamLine("%d", rotationSpeed);
		//motor[left]	= currentSpeed - -rotationSpeed * 2;
		//motor[right] = currentSpeed - rotationSpeed * 2;
	}
	motor[left]	= 0;
	motor[right] = 0;
}
void moveBottomClaw(bool raise){
	if(raise){
		motor[frontClaw] = 100;
	}
	else{
		motor[frontClaw] = -100;
	}
	while(getMotorCurrent(frontClaw) < 500){writeDebugStreamLine("%d", getMotorCurrent(frontClaw));}
	motor[frontClaw] = 0;
}

void moveArm(int amount, int speed){
	resetMotorEncoder(leftArmMotor);
	resetMotorEncoder(rightArmMotor);
	if(amount > 0){
		motor[leftArmMotor]	= speed;
		motor[rightArmMotor]	= speed;
	}
	else if(amount < 0){
		motor[leftArmMotor]	= -speed;
		motor[rightArmMotor]	= -speed;
	}
	else{
		motor[leftArmMotor]	= 0;
		motor[rightArmMotor] = 0;
	}
	while(abs((getMotorEncoder(rightArmMotor) + getMotorEncoder(leftArmMotor)) / 2 - amount) > 20){
	}
	motor[leftArmMotor]	= 0;
	motor[rightArmMotor] = 0;
}
void firstRiser(){
	resetGyro(gyro);

	wait1Msec(100);

	drive(100, 100);

	rotate(-87);

	strafe(-430, 100);

	wait1Msec(300);

	moveArm(100, 100);

	drive(900, 60);

	wait1Msec(200);

	moveArm(360, 70);

	drive(-400, 50);

	strafe(390, 70);

	rotate(-88);

	drive(360, 50);

	//moveBottomClaw(true);

	drive(285, 70);

	rotate(-88);

	moveBottomClaw(false);

	drive(-200, 60);

	moveArm(-150, 40);

	drive(-500, 70);
}

void middleRiser(){
	resetGyro(gyro);

	strafe(600, 100);

	drive(1500, 80);

	rotate(86);

	drive(650, 100);

	drive(-300, 100);

	rotate(-85);
	//moveArm(390, 100)

	drive(1000, 80);

	wait1Msec(400);

	drive(-500, 80);

}

void lastRiser(){
	resetGyro(gyro);

	moveArm(-210, 100);

	strafe(640, 100);

	rotate(0);

	drive(2500, 100);

	rotate(-86);

	drive(600, 70);

	moveArm(290, 100);

	drive(-500, 70);
}
task main()
{
	//firstRiser();
	//wait1Msec(5000);
	moveArm(310, 100)
	middleRiser();
	//lastRiser();
	while(true){}

} //COMMENT YOUR CODE BETTER
